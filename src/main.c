/* =========================================================================================================
   Case:      Brno University of Technology, IMP - Microprocessors and Embedded Systems
   Date:      16.12.2021
   Author:    Vladislav Sokolovskii
   Contact:   xsokol15@stud.fit.vutbr.cz
   Description: Heart rate measurement with ESP32, OLED display SSD1306 and pulse sensor
   ========================================================================================================== */

// C libraries
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "sys/time.h"

// ESP32 espressif libraries
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "driver/adc.h"
#include "driver/i2c.h"
#include "esp_adc_cal.h"
#include "esp_timer.h"
#include "esp_log.h"
#include "esp_sleep.h"

// Open source library
#include "sdkconfig.h" // generated by "make menuconfig"
#include "ssd1366.h"
#include "font8x8_basic.h"

// Pins definition
#define SDA_PIN GPIO_NUM_21
#define SCL_PIN GPIO_NUM_22

// Project specific constant values
#define DEFAULT_VREF            1100
#define NUMBER_OF_SAMPLES       150
#define DEFAULT_SENSOR_OUTPUT   1630            // (Vcc / 2) is the default output voltage of the sensor according to the datasheet
#define BPM_WINDOW_SIZE         5               // Window size of BPM measurements to calcurate the average BPM on
#define I2C_MASTER_FREQ_HZ      100000
#define I2C_MASTER_TX_BUF_DISABLE   0           /*!< I2C master doesn't need buffer */
#define I2C_MASTER_RX_BUF_DISABLE   0           /*!< I2C master doesn't need buffer */
#define MINIMUM_HEART_RATE          33

// Project tag for debug output
static const char *TAG = "Heart beat project";

// ADC setup
static esp_adc_cal_characteristics_t *adc_chars;
static const adc_channel_t channel = ADC1_CHANNEL_0;     //GPIO38
static const adc_bits_width_t width = ADC_WIDTH_BIT_12;  
static const adc_atten_t atten = ADC_ATTEN_DB_11;
static const adc_unit_t unit = ADC_UNIT_1;

/**
 * @brief This function reads raw signal from the analogue GPIO36 and converts it to voltage.
 * It makes multisampling on NUM_OF_SAMPLES measurings and returns the average volatage from the sensor.
 */
uint32_t read_sensor_voltage();

/**
 * @brief Calculates the number of signal peaks in last NUMBER_OF_SAMPLES of the singal from GPIO36 channel.
 * Converts number of peaks to the BPM.
 * @return int - Beats per minute
 */
int get_bpm();

/**
 * This function was borrowed from https://github.com/espressif/esp-idf
 * Title: I2C Simple Example
 * Credit: Espressif Systems
 * Date of last change: Nov 18, 2021
 * Availability: https://github.com/espressif/esp-idf/tree/master/examples/peripherals/i2c/i2c_simple
 */
static esp_err_t i2c_master_init();

/**
 * @brief This function checks eFuse bits and makes sure that connected board is ready 
 * 
 * This function was borrowed from https://github.com/espressif/esp-idf
 * Title: ADC1 Example
 * Credit: Espressif Systems
 * Date of last change: Nov 11, 2021
 * Availability: https://github.com/espressif/esp-idf/tree/master/examples/peripherals/adc/single_read/adc
 */
static void check_efuse(void);

/**
 * @brief This function initializes SSD1306 display for I2C communication
 *
 * This function was borrowed from https://github.com/yanbe/ssd1306-esp-idf-i2c
 * Title: Sample code for driving 128x64 OLED display with SSD1306 driver via ESP-IDF's I2C master driver
 * Credit: yanbe (https://github.com/yanbe)
 * Date of last change: May 3, 2017
 * Availability: https://github.com/yanbe/ssd1306-esp-idf-i2c/blob/master/main/main.c
 */
void ssd1306_init();

/**
 * @brief This function accepts String as an input and display it on SSD1306 oled display
 * 
 * This function was borrowed from https://github.com/yanbe/ssd1306-esp-idf-i2c
 * Title: Sample code for driving 128x64 OLED display with SSD1306 driver via ESP-IDF's I2C master driver
 * Credit: yanbe (https://github.com/yanbe)
 * Date of last change: May 3, 2017
 * Availability: https://github.com/yanbe/ssd1306-esp-idf-i2c/blob/master/main/main.c
 */
void task_ssd1306_display_text(void *arg_text);


//========================================== FUNCTION DEFENITIONS START

uint32_t read_sensor_voltage() {
    static int sum = 0;
    static int window[NUMBER_OF_SAMPLES];
    static int index;

    uint32_t tmp_adc_reading = 0;   // raw sensor input
    uint32_t voltage;               // raw converted to voltage

    for (int i =0; i < NUMBER_OF_SAMPLES; i++) {
        sum = sum - window[index];                              // Remove the oldest entry from the sum
        tmp_adc_reading = adc1_get_raw((adc1_channel_t)channel);
        voltage = esp_adc_cal_raw_to_voltage(tmp_adc_reading, adc_chars);

        window[index] = voltage;                                // Add the newest reading to the window
        sum = sum + voltage;                                    // Add the newest reading to the sum
        index = (index+1) % NUMBER_OF_SAMPLES;                  // Increment the index, and wrap to 0 if it exceeds the window size
    }

    int averaged = sum / NUMBER_OF_SAMPLES; 
    // noise check, if noise then return zero, otherwise input voltage - default voltage output
    int output = (averaged - DEFAULT_SENSOR_OUTPUT < 0 || averaged - DEFAULT_SENSOR_OUTPUT > 150) ? 0 : averaged - DEFAULT_SENSOR_OUTPUT;

    return output;
}

int get_bpm() {
    // random window size, the heart signal is periodic and we could always cut the same part of the period
    // using the random wndow size the effect of signal cutting is decreased
    const int top_edge = 65;
    const int bottom_edge = 55;
    int samples_number = (esp_random() % (top_edge -bottom_edge + 1)) + bottom_edge;

    struct timeval start, stop;
    int pulse[samples_number];
    int beats = 0;
    double secs;

    gettimeofday(&start, NULL);
    for(int j = 0; j < samples_number; j++) {
        pulse[j] = read_sensor_voltage();
        vTaskDelay((esp_random() % 20) + 1); // wait random time
    }
    gettimeofday(&stop, NULL);
    secs = (double)(stop.tv_usec - start.tv_usec) / 1000000 + (double)(stop.tv_sec - start.tv_sec);

    int peak_value = -1;
    int peak_index = -1;
    int sum = 0;

    for(int i=0; i< samples_number; i++) {
        sum = sum + pulse[i];
    }

    int baseline = sum / samples_number;

    for (int k = 0; k < samples_number; k++) {
        if(pulse[k] > baseline && pulse[k] - baseline > 6) {
            if (peak_value == -1 || pulse[k] > peak_value) {
                peak_index = k;
                peak_value = pulse[k];
            }
        } else if (pulse[k] < baseline && peak_index != -1) {
            beats++;
            peak_index = -1;
            peak_value = -1;
        }
    }
    if (peak_index != -1 && beats != 0) {
        beats++;
    }

    int bpm = round(((60.0 / secs) * beats));
    return bpm;
}

void app_main(void)
{
    //Initialize the display
    ESP_ERROR_CHECK(i2c_master_init());
    ESP_LOGI(TAG, "I2C initialized successfully");
	ssd1306_init();
    char text_to_display[150];

    //Check if Two Point or Vref are burned into eFuse
    check_efuse();

    //Configure ADC
    adc1_config_width(width);
    adc1_config_channel_atten(channel, atten);

    //Characterize ADC
    adc_chars = calloc(1, sizeof(esp_adc_cal_characteristics_t));
    esp_adc_cal_value_t val_type = esp_adc_cal_characterize(unit, atten, width, DEFAULT_VREF, adc_chars);
    if (val_type == ESP_ADC_CAL_VAL_EFUSE_TP) {
        printf("Characterized using Two Point Value\n");
    } else if (val_type == ESP_ADC_CAL_VAL_EFUSE_VREF) {
        printf("Characterized using eFuse Vref\n");
    } else {
        printf("Characterized using Default Vref\n");
    }

    xTaskCreate(task_ssd1306_display_text, "ssd1306_display_text",  2048, PUT_FINGER_STRING, 6, NULL);

    static int bpm_sum = 0;
    static int bpm_window[BPM_WINDOW_SIZE] = {0};
    static int idx = 0;

    uint32_t curr_bpm;
    uint32_t averaged_pulse;

    while (1) {
        for (int i = 0; i < BPM_WINDOW_SIZE; i++) {
            bpm_sum = bpm_sum - bpm_window[idx];            // Remove the oldest entry from the sum
            
            curr_bpm = get_bpm();                           // Get current beats per minute rate
            printf("Curr rate %d\n", curr_bpm);

            if (curr_bpm < MINIMUM_HEART_RATE) {
                do {
                    curr_bpm = get_bpm();

                    //Finger was removed from the sensor
                    if (curr_bpm < MINIMUM_HEART_RATE && bpm_sum != 0) {
                        bpm_sum = 0;
                        for (int p = 0; p < BPM_WINDOW_SIZE; p++)
                            bpm_window[p] = 0;
                        ESP_LOGI(TAG, "BPM 0\n");    
       
                        xTaskCreate(task_ssd1306_display_text, "ssd1306_display_text",  2048, PUT_FINGER_STRING, 6, NULL);
                    }
                } while(curr_bpm < 30);
            }

            bpm_window[idx] = curr_bpm;                     // Add the newest reading to the window
            bpm_sum = bpm_sum + curr_bpm;                   // Add the newest reading to the sum
            idx = (idx+1) % BPM_WINDOW_SIZE;                // Increment the index, and wrap to 0 if it exceeds the window size

            // Count the number of non-zero values in the BPM window
            int non_zero = 0;
            for (int k = 0; k < BPM_WINDOW_SIZE; k++) {
                if (bpm_window[k] != 0)
                    non_zero++;
            }

            // Calculate BPM, averaged across last five non-zero measurements
            averaged_pulse = bpm_sum / non_zero;
            ESP_LOGI(TAG, "Current BPM %d\n", averaged_pulse);
		    sprintf(text_to_display, BPM_STRING, averaged_pulse);
            xTaskCreate(task_ssd1306_display_text, "ssd1306_display_text",  2048, text_to_display , 6, NULL);
        }//for
    }//while
}//app_main


//========================================== BORROWED FUNCTIONS

static esp_err_t i2c_master_init()
{
	i2c_config_t i2c_config = {
		.mode = I2C_MODE_MASTER,
		.sda_io_num = SDA_PIN,
		.scl_io_num = SCL_PIN,
		.sda_pullup_en = GPIO_PULLUP_ENABLE,
		.scl_pullup_en = GPIO_PULLUP_ENABLE,
		.master.clk_speed = I2C_MASTER_FREQ_HZ
	};
	i2c_param_config(I2C_NUM_0, &i2c_config);

	return i2c_driver_install(I2C_NUM_0, I2C_MODE_MASTER, I2C_MASTER_RX_BUF_DISABLE, I2C_MASTER_TX_BUF_DISABLE, 0);
}

void ssd1306_init() {
	esp_err_t espRc;

	i2c_cmd_handle_t cmd = i2c_cmd_link_create();

	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_CHARGE_PUMP, true);
	i2c_master_write_byte(cmd, 0x14, true);

	i2c_master_write_byte(cmd, OLED_CMD_SET_SEGMENT_REMAP, true); // reverse left-right mapping
	i2c_master_write_byte(cmd, OLED_CMD_SET_COM_SCAN_MODE, true); // reverse up-bottom mapping

	i2c_master_write_byte(cmd, OLED_CMD_DISPLAY_ON, true);
	i2c_master_stop(cmd);

	espRc = i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	if (espRc == ESP_OK) {
		ESP_LOGI(TAG, "OLED configured successfully");
	} else {
		ESP_LOGE(TAG, "OLED configuration failed. code: 0x%.2X", espRc);
	}
	i2c_cmd_link_delete(cmd);
}

void task_ssd1306_display_text(void *arg_text) {
	char *text = arg_text;
	uint8_t text_len = strlen(text);

	i2c_cmd_handle_t cmd;

	uint8_t cur_page = 0;

	cmd = i2c_cmd_link_create();
	i2c_master_start(cmd);
	i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

	i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
	i2c_master_write_byte(cmd, 0x00, true); // reset column
	i2c_master_write_byte(cmd, 0x10, true);
	i2c_master_write_byte(cmd, 0xB0 | cur_page, true); // reset page

	i2c_master_stop(cmd);
	i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
	i2c_cmd_link_delete(cmd);

	for (uint8_t i = 0; i < text_len; i++) {
		if (text[i] == '\n') {
			cmd = i2c_cmd_link_create();
			i2c_master_start(cmd);
			i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
			i2c_master_write_byte(cmd, 0x00, true); // reset column
			i2c_master_write_byte(cmd, 0x10, true);
			i2c_master_write_byte(cmd, 0xB0 | ++cur_page, true); // increment page

			i2c_master_stop(cmd);
			i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
			i2c_cmd_link_delete(cmd);
		} else {
			cmd = i2c_cmd_link_create();
			i2c_master_start(cmd);
			i2c_master_write_byte(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			i2c_master_write_byte(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
			i2c_master_write(cmd, font8x8_basic_tr[(uint8_t)text[i]], 8, true);

			i2c_master_stop(cmd);
			i2c_master_cmd_begin(I2C_NUM_0, cmd, 10/portTICK_PERIOD_MS);
			i2c_cmd_link_delete(cmd);
		}
	}

	vTaskDelete(NULL);
}

static void check_efuse(void)
{
    //Check if TP is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_TP) == ESP_OK) {
        printf("eFuse Two Point: Supported\n");
    } else {
        printf("eFuse Two Point: NOT supported\n");
    }
    //Check Vref is burned into eFuse
    if (esp_adc_cal_check_efuse(ESP_ADC_CAL_VAL_EFUSE_VREF) == ESP_OK) {
        printf("eFuse Vref: Supported\n");
    } else {
        printf("eFuse Vref: NOT supported\n");
    }
}
